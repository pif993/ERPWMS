// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertStockLedgerMove = `-- name: InsertStockLedgerMove :one
INSERT INTO stock_ledger (
  item_id, qty, from_location_id, to_location_id, reason_code, ref_type, ref_id, actor_user_id, request_id
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
RETURNING move_id, ts, item_id, qty, from_location_id, to_location_id, reason_code, ref_type, ref_id, actor_user_id, request_id
`

type InsertStockLedgerMoveParams struct {
	ItemID         pgtype.UUID
	Qty            pgtype.Numeric
	FromLocationID pgtype.UUID
	ToLocationID   pgtype.UUID
	ReasonCode     string
	RefType        pgtype.Text
	RefID          pgtype.Text
	ActorUserID    pgtype.UUID
	RequestID      pgtype.Text
}

func (q *Queries) InsertStockLedgerMove(ctx context.Context, arg InsertStockLedgerMoveParams) (StockLedger, error) {
	row := q.db.QueryRow(ctx, insertStockLedgerMove,
		arg.ItemID,
		arg.Qty,
		arg.FromLocationID,
		arg.ToLocationID,
		arg.ReasonCode,
		arg.RefType,
		arg.RefID,
		arg.ActorUserID,
		arg.RequestID,
	)
	var i StockLedger
	err := row.Scan(
		&i.MoveID,
		&i.Ts,
		&i.ItemID,
		&i.Qty,
		&i.FromLocationID,
		&i.ToLocationID,
		&i.ReasonCode,
		&i.RefType,
		&i.RefID,
		&i.ActorUserID,
		&i.RequestID,
	)
	return i, err
}

const listStockBalances = `-- name: ListStockBalances :many
SELECT sb.item_id, sb.location_id, sb.qty_on_hand, sb.qty_allocated, sb.updated_at,
       i.sku, i.name item_name, l.code location_code, w.code warehouse_code
FROM stock_balance sb
JOIN items i ON i.id = sb.item_id
JOIN locations l ON l.id = sb.location_id
JOIN warehouses w ON w.id = l.warehouse_id
WHERE ($1::text = '' OR i.sku ILIKE '%' || $1 || '%' OR i.name ILIKE '%' || $1 || '%')
  AND ($2::text = '' OR w.code = $2)
  AND ($3::text = '' OR l.code = $3)
ORDER BY i.sku, l.code
LIMIT $4 OFFSET $5
`

type ListStockBalancesParams struct {
	Column1 string
	Column2 string
	Column3 string
	Limit   int32
	Offset  int32
}

type ListStockBalancesRow struct {
	ItemID        pgtype.UUID
	LocationID    pgtype.UUID
	QtyOnHand     pgtype.Numeric
	QtyAllocated  pgtype.Numeric
	UpdatedAt     pgtype.Timestamptz
	Sku           string
	ItemName      string
	LocationCode  string
	WarehouseCode string
}

func (q *Queries) ListStockBalances(ctx context.Context, arg ListStockBalancesParams) ([]ListStockBalancesRow, error) {
	rows, err := q.db.Query(ctx, listStockBalances,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockBalancesRow
	for rows.Next() {
		var i ListStockBalancesRow
		if err := rows.Scan(
			&i.ItemID,
			&i.LocationID,
			&i.QtyOnHand,
			&i.QtyAllocated,
			&i.UpdatedAt,
			&i.Sku,
			&i.ItemName,
			&i.LocationCode,
			&i.WarehouseCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStockBalanceDelta = `-- name: UpsertStockBalanceDelta :exec
INSERT INTO stock_balance (item_id, location_id, qty_on_hand, qty_allocated)
VALUES ($1, $2, $3, $4)
ON CONFLICT (item_id, location_id)
DO UPDATE SET
  qty_on_hand = stock_balance.qty_on_hand + EXCLUDED.qty_on_hand,
  qty_allocated = stock_balance.qty_allocated + EXCLUDED.qty_allocated,
  updated_at = now()
`

type UpsertStockBalanceDeltaParams struct {
	ItemID       pgtype.UUID
	LocationID   pgtype.UUID
	QtyOnHand    pgtype.Numeric
	QtyAllocated pgtype.Numeric
}

func (q *Queries) UpsertStockBalanceDelta(ctx context.Context, arg UpsertStockBalanceDeltaParams) error {
	_, err := q.db.Exec(ctx, upsertStockBalanceDelta,
		arg.ItemID,
		arg.LocationID,
		arg.QtyOnHand,
		arg.QtyAllocated,
	)
	return err
}
